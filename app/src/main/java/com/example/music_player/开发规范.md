# 音乐播放器应用开发规范（基于现有结构）
基于Jetpack Compose框架，使用ViewModel、Navigation、Retrofit、Room等组件提供的功能，构建一个完整的安卓应用。
## 1. 项目结构优化建议

### 1.1 现有结构调整
```
com.example.music_player
├── data/
│   ├── local/                  # 本地数据源
│   │   ├── dao/               # DAO 接口
│   │   │   ├── FavoriteMusicDao.kt
│   │   │   ├── PlayHistoryDao.kt
│   │   │   └── UserDao.kt
│   │   ├── entity/            # Room 实体类
│   │   │   ├── FavoriteMusic.kt
│   │   │   ├── PlayHistory.kt
│   │   │   └── User.kt
│   │   └── AppDatabase.kt
│   ├── remote/                # 网络数据源
│   │   └── UserService.kt
│   ├── repository/            # 数据仓库
│   │   ├── MusicRepository.kt
│   │   └── UserRepository.kt
│   ├── model/                 # 共享数据模型
│   │   ├── Gender.kt
│   │   └── MusicFile.kt
│   └── DataStoreManager.kt
├── navigation/
│   └── AppNavigation.kt
├── service/                   # 后台服务
│   ├── MusicService.kt
│   └── MusicServiceConnection.kt
└── ui/
    ├── theme/
    │   ├── Color.kt
    │   ├── Theme.kt
    │   └── Type.kt
    ├── component/             # 可复用组件
    │   ├── BottomPlayerBar.kt
    │   └── ScrollingTitle.kt
    ├── screen/               # 各功能屏幕
    │   ├── auth/             # 认证相关
    │   │   ├── LoginScreen.kt
    │   │   └── RegisterScreen.kt
    │   ├── main/             # 主功能
    │   │   ├── MainScreen.kt
    │   │   ├── UserHomeScreen.kt
    │   │   ├── FavoriteScreen.kt
    │   │   ├── PlayerScreen.kt
    │   │   └── PlayHistoryScreen.kt
    │   ├── profile/          # 用户相关
    │   │   └── ProfileScreen.kt
    │   └── admin/            # 管理功能
    │       └── AdminScreen.kt
    ├── viewmodel/            # ViewModel
    │   ├── AdminViewModel.kt
    │   ├── LoginViewModel.kt
    │   ├── PlayerViewModel.kt
    │   ├── ProfileViewModel.kt
    │   └── UserViewModel.kt
    └── MainActivity.kt
```

## 2. 代码规范（最小改动）

### 2.1 ViewModel 规范（保持现有 Factory）
```kotlin
// 保持现有的 ViewModelFactory，但添加统一基类
abstract class BaseViewModel : ViewModel() {
    
    // 统一 UI 状态处理
    sealed interface UiState<T> {
        data object Loading : UiState<Nothing>
        data class Success<T>(val data: T) : UiState<T>
        data class Error(val message: String) : UiState<Nothing>
    }
    
    // 统一错误处理
    protected fun handleError(throwable: Throwable): String {
        return throwable.message ?: "未知错误"
    }
}

// 现有 ViewModel 继承 BaseViewModel
class LoginViewModel(
    private val userRepository: UserRepository
) : BaseViewModel() {
    
    // 使用密封类管理状态
    sealed class LoginState {
        data object Idle : LoginState()
        data object Loading : LoginState()
        data class Success(val user: User) : LoginState()
        data class Error(val message: String) : LoginState()
    }
    
    private val _loginState = MutableStateFlow<LoginState>(LoginState.Idle)
    val loginState: StateFlow<LoginState> = _loginState.asStateFlow()
    
    fun login(username: String, password: String) {
        viewModelScope.launch {
            _loginState.value = LoginState.Loading
            try {
                val user = userRepository.login(username, password)
                _loginState.value = LoginState.Success(user)
            } catch (e: Exception) {
                _loginState.value = LoginState.Error(handleError(e))
            }
        }
    }
}
```

### 2.2 Repository 模式优化
```kotlin
class MusicRepository(
    private val musicDao: MusicDao,
    private val musicService: MusicService
) {
    // 统一数据获取模式
    suspend fun getFavoriteMusic(): Result<List<MusicFile>> = runCatching {
        // 先返回本地数据
        val localData = musicDao.getFavorites()
        
        // 异步更新网络数据
        viewModelScope.launch {
            try {
                val remoteData = musicService.getFavorites()
                musicDao.insertAll(remoteData)
            } catch (e: Exception) {
                // 记录日志但不影响当前返回
                Log.e("MusicRepository", "更新收藏失败", e)
            }
        }
        
        localData
    }
    
    // 统一返回值类型
    suspend fun searchMusic(query: String): Result<List<MusicFile>> = runCatching {
        val localResults = musicDao.searchLocal(query)
        if (localResults.isNotEmpty()) {
            return@runCatching localResults
        }
        
        val remoteResults = musicService.search(query)
        musicDao.insertAll(remoteResults)
        remoteResults
    }
}
```

### 2.3 UI 组件规范
```kotlin
// 1. 状态管理组件
@Composable
fun <T> StateHandler(
    state: UiState<T>,
    onLoading: @Composable () -> Unit,
    onSuccess: @Composable (T) -> Unit,
    onError: @Composable (String) -> Unit
) {
    when (state) {
        is UiState.Loading -> onLoading()
        is UiState.Success -> onSuccess(state.data)
        is UiState.Error -> onError(state.message)
    }
}

// 2. 屏幕组件模板
@Composable
fun BaseScreen(
    title: String,
    isLoading: Boolean = false,
    onBackClick: (() -> Unit)? = null,
    content: @Composable (PaddingValues) -> Unit
) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(title) },
                navigationIcon = if (onBackClick != null) {
                    {
                        IconButton(onClick = onBackClick) {
                            Icon(Icons.Default.ArrowBack, contentDescription = "返回")
                        }
                    }
                } else null
            )
        }
    ) { paddingValues ->
        if (isLoading) {
            Box(modifier = Modifier.fillMaxSize()) {
                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
            }
        } else {
            content(paddingValues)
        }
    }
}

// 3. 播放器控制组件
@Composable
fun PlayerController(
    viewModel: PlayerViewModel,
    modifier: Modifier = Modifier
) {
    val playerState by viewModel.playerState.collectAsState()
    
    Row(
        modifier = modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly,
        verticalAlignment = Alignment.CenterVertically
    ) {
        IconButton(onClick = { viewModel.previous() }) {
            Icon(Icons.Default.SkipPrevious, contentDescription = "上一首")
        }
        
        IconButton(onClick = { 
            if (playerState.isPlaying) viewModel.pause() else viewModel.play() 
        }) {
            Icon(
                if (playerState.isPlaying) Icons.Default.Pause else Icons.Default.PlayArrow,
                contentDescription = if (playerState.isPlaying) "暂停" else "播放"
            )
        }
        
        IconButton(onClick = { viewModel.next() }) {
            Icon(Icons.Default.SkipNext, contentDescription = "下一首")
        }
    }
}
```

### 2.4 Navigation 使用规范
```kotlin
// 1. 统一定义路由
sealed class Screen(val route: String) {
    object Splash : Screen("splash")
    object Login : Screen("login")
    object Register : Screen("register")
    object Home : Screen("home")
    object Profile : Screen("profile")
    object Player : Screen("player/{musicId}") {
        fun createRoute(musicId: String) = "player/$musicId"
    }
    object Favorites : Screen("favorites")
    object History : Screen("history")
    object Admin : Screen("admin")
}

// 2. 导航扩展函数
fun NavHostController.navigateToPlayer(musicId: String) {
    navigate(Screen.Player.createRoute(musicId))
}

// 3. 在主 Activity 中设置导航
@Composable
fun MusicPlayerApp() {
    val navController = rememberNavController()
    
    NavHost(
        navController = navController,
        startDestination = Screen.Splash.route
    ) {
        composable(Screen.Splash.route) {
            SplashScreen(
                onNavigateToHome = { navController.navigate(Screen.Home.route) },
                onNavigateToLogin = { navController.navigate(Screen.Login.route) }
            )
        }
        
        composable(Screen.Login.route) {
            LoginScreen(
                onLoginSuccess = { navController.navigate(Screen.Home.route) },
                onNavigateToRegister = { navController.navigate(Screen.Register.route) }
            )
        }
        
        composable(Screen.Home.route) {
            UserHomeScreen(
                onNavigateToPlayer = { musicId -> navController.navigateToPlayer(musicId) },
                onNavigateToProfile = { navController.navigate(Screen.Profile.route) }
            )
        }
        
        // ... 其他屏幕
    }
}
```

## 3. 配置与依赖管理

### 3.1 模块级 build.gradle 配置
```gradle
android {
    defaultConfig {
        // 统一版本配置
        versionCode 1
        versionName "1.0.0"
    }
    
    buildFeatures {
        compose true
        viewBinding true
    }
    
    composeOptions {
        kotlinCompilerExtensionVersion "1.5.3"
    }
}

dependencies {
    // Jetpack Compose
    implementation "androidx.compose.ui:ui:1.5.0"
    implementation "androidx.compose.material3:material3:1.1.1"
    implementation "androidx.compose.ui:ui-tooling-preview:1.5.0"
    implementation "androidx.activity:activity-compose:1.7.2"
    
    // Lifecycle
    implementation "androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1"
    implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.6.1"
    
    // Room
    implementation "androidx.room:room-runtime:2.5.2"
    implementation "androidx.room:room-ktx:2.5.2"
    kapt "androidx.room:room-compiler:2.5.2"
    
    // Navigation
    implementation "androidx.navigation:navigation-compose:2.7.0"
    
    // Retrofit (如果有网络需求)
    implementation "com.squareup.retrofit2:retrofit:2.9.0"
    implementation "com.squareup.retrofit2:converter-gson:2.9.0"
    
    // DataStore
    implementation "androidx.datastore:datastore-preferences:1.0.0"
}
```

## 4. 开发工作流

### 4.1 新功能开发步骤
1. **数据层**：
    - 在 `data/model` 添加数据模型
    - 在 `data/local/entity` 添加 Room 实体
    - 在 `data/local/dao` 添加 DAO 接口
    - 在 `data/repository` 添加 Repository

2. **业务逻辑层**：
    - 在 `ui/viewmodel` 添加 ViewModel
    - 继承 `BaseViewModel`
    - 使用 `UiState` 管理状态

3. **表现层**：
    - 在 `ui/screen` 添加屏幕组件
    - 使用 `BaseScreen` 模板
    - 使用 `StateHandler` 处理状态

4. **导航**：
    - 在 `Screen` 密封类中添加路由
    - 在 `AppNavigation.kt` 中添加导航图

### 4.2 命名规范
- **ViewModel**: `功能名 + ViewModel`
- **Screen**: `功能名 + Screen`
- **Repository**: `功能名 + Repository`
- **状态**: `uiState` (StateFlow), `事件` (SharedFlow)

### 4.3 代码质量检查
在开发前检查：
- [ ] ViewModel 是否继承 BaseViewModel
- [ ] 状态管理是否使用 UiState
- [ ] 错误处理是否统一
- [ ] 组件是否可复用
- [ ] 导航路由是否正确添加